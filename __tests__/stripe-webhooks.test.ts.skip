import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { POST } from '@/app/api/stripe/webhooks/route';
import { stripe } from '@/lib/stripe';
import { db } from '@/db/db';
import { transactionsTable, bookingsTable } from '@/db/schema';
import { eq } from 'drizzle-orm';

// Mock Stripe
vi.mock('@/lib/stripe', () => ({
  stripe: {
    webhooks: {
      constructEvent: vi.fn(),
    },
  },
}));

// Mock database
vi.mock('@/db/db', () => ({
  db: {
    update: vi.fn(() => ({
      set: vi.fn(() => ({
        where: vi.fn(() => ({
          returning: vi.fn(() => Promise.resolve([{ id: 'test-id' }])),
        })),
      })),
    })),
    select: vi.fn(() => ({
      from: vi.fn(() => ({
        where: vi.fn(() => ({
          limit: vi.fn(() => Promise.resolve([{ bookingId: 'test-booking' }])),
        })),
      })),
    })),
    transaction: vi.fn((callback) => callback(db)),
  },
}));

describe('Stripe Webhook Handlers', () => {
  const mockRequest = (body: string, signature: string) => ({
    text: () => Promise.resolve(body),
    headers: new Headers({
      'stripe-signature': signature,
    }),
  });

  beforeEach(() => {
    vi.clearAllMocks();
    process.env.STRIPE_WEBHOOK_SECRET = 'test_webhook_secret';
  });

  describe('Transfer Events', () => {
    it('should handle transfer.paid event', async () => {
      const event = {
        id: 'evt_test_1',
        type: 'transfer.paid',
        data: {
          object: {
            id: 'tr_test_1',
            amount: 9000, // $90 in cents
            currency: 'usd',
            metadata: {
              bookingId: 'booking_123',
            },
          },
        },
      };

      vi.mocked(stripe.webhooks.constructEvent).mockReturnValue(event as any);

      const request = mockRequest(JSON.stringify(event), 'test_signature');
      const response = await POST(request as any);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.received).toBe(true);
    });

    it('should handle transfer.failed event', async () => {
      const event = {
        id: 'evt_test_2',
        type: 'transfer.failed',
        data: {
          object: {
            id: 'tr_test_2',
            amount: 9000,
            currency: 'usd',
            metadata: {
              bookingId: 'booking_124',
            },
          },
        },
      };

      vi.mocked(stripe.webhooks.constructEvent).mockReturnValue(event as any);

      const request = mockRequest(JSON.stringify(event), 'test_signature');
      const response = await POST(request as any);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.received).toBe(true);
    });
  });

  describe('Payment Intent Events', () => {
    it('should handle payment_intent.succeeded for booking', async () => {
      const event = {
        id: 'evt_test_3',
        type: 'payment_intent.succeeded',
        data: {
          object: {
            id: 'pi_test_1',
            amount: 11000, // $110 in cents (includes fees)
            currency: 'usd',
            latest_charge: 'ch_test_1',
            metadata: {
              bookingId: 'booking_125',
              type: 'booking_payment',
            },
          },
        },
      };

      vi.mocked(stripe.webhooks.constructEvent).mockReturnValue(event as any);

      const request = mockRequest(JSON.stringify(event), 'test_signature');
      const response = await POST(request as any);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.received).toBe(true);
    });

    it('should ignore payment_intent.succeeded without booking metadata', async () => {
      const event = {
        id: 'evt_test_4',
        type: 'payment_intent.succeeded',
        data: {
          object: {
            id: 'pi_test_2',
            amount: 5000,
            currency: 'usd',
            metadata: {
              // No booking metadata
            },
          },
        },
      };

      vi.mocked(stripe.webhooks.constructEvent).mockReturnValue(event as any);

      const request = mockRequest(JSON.stringify(event), 'test_signature');
      const response = await POST(request as any);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.received).toBe(true);
    });
  });

  describe('Charge Dispute Events', () => {
    it('should handle charge.dispute.created', async () => {
      const event = {
        id: 'evt_test_5',
        type: 'charge.dispute.created',
        data: {
          object: {
            id: 'dp_test_1',
            charge: 'ch_test_1',
            amount: 11000,
            currency: 'usd',
            reason: 'fraudulent',
          },
        },
      };

      vi.mocked(stripe.webhooks.constructEvent).mockReturnValue(event as any);

      const request = mockRequest(JSON.stringify(event), 'test_signature');
      const response = await POST(request as any);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.received).toBe(true);
    });
  });

  describe('Security', () => {
    it('should reject requests without signature', async () => {
      const request = {
        text: () => Promise.resolve('{}'),
        headers: new Headers(),
      };

      const response = await POST(request as any);
      const data = await response.json();

      expect(response.status).toBe(401);
      expect(data.error).toBe('Unauthorized');
    });

    it('should reject requests with invalid signature', async () => {
      vi.mocked(stripe.webhooks.constructEvent).mockImplementation(() => {
        throw new Error('Invalid signature');
      });

      const request = mockRequest('{}', 'invalid_signature');
      const response = await POST(request as any);
      const data = await response.json();

      expect(response.status).toBe(401);
      expect(data.error).toBe('Unauthorized');
    });
  });

  describe('Idempotency', () => {
    it('should handle duplicate events gracefully', async () => {
      const event = {
        id: 'evt_duplicate',
        type: 'payment_intent.succeeded',
        data: {
          object: {
            id: 'pi_duplicate',
            metadata: {
              bookingId: 'booking_dup',
              type: 'booking_payment',
            },
          },
        },
      };

      vi.mocked(stripe.webhooks.constructEvent).mockReturnValue(event as any);

      const request = mockRequest(JSON.stringify(event), 'test_signature');
      
      // First call
      const response1 = await POST(request as any);
      expect(response1.status).toBe(200);
      
      // Second call (duplicate)
      const response2 = await POST(request as any);
      expect(response2.status).toBe(200);
      
      // Both should succeed due to idempotency
      const data1 = await response1.json();
      const data2 = await response2.json();
      expect(data1.received).toBe(true);
      expect(data2.received).toBe(true);
    });
  });
});

describe('Webhook Event Processing', () => {
  it('should update booking status on payment success', async () => {
    const mockBooking = {
      id: 'booking_test',
      status: 'pending',
      stripePaymentIntentId: 'pi_test',
    };

    const mockTransaction = {
      id: 'tx_test',
      bookingId: 'booking_test',
      status: 'pending',
    };

    // Mock database queries
    vi.mocked(db.select).mockReturnValue({
      from: vi.fn(() => ({
        where: vi.fn(() => ({
          limit: vi.fn(() => Promise.resolve([mockTransaction])),
        })),
      })),
    } as any);

    vi.mocked(db.update).mockReturnValue({
      set: vi.fn(() => ({
        where: vi.fn(() => ({
          returning: vi.fn(() => Promise.resolve([{ ...mockBooking, status: 'confirmed' }])),
        })),
      })),
    } as any);

    const event = {
      id: 'evt_booking_success',
      type: 'payment_intent.succeeded',
      data: {
        object: {
          id: 'pi_test',
          latest_charge: 'ch_test',
          metadata: {
            bookingId: 'booking_test',
            type: 'booking_payment',
          },
        },
      },
    };

    vi.mocked(stripe.webhooks.constructEvent).mockReturnValue(event as any);

    const request = mockRequest(JSON.stringify(event), 'test_signature');
    const response = await POST(request as any);

    expect(response.status).toBe(200);
    // Verify database was updated
    expect(db.update).toHaveBeenCalled();
  });
});
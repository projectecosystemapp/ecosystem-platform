#!/usr/bin/env node
/**
 * Type Generation Pipeline
 * 
 * Generates TypeScript types from database schemas and validates
 * schema-to-runtime alignment. Ensures single source of truth.
 */

import { execSync } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';
import { z } from 'zod';

const CONFIG = {
  schemaDir: './db/schema',
  typesDir: './types/generated',
  validationFile: './types/validation.ts',
  drizzleConfig: './drizzle.config.ts',
};

/**
 * Step 1: Generate types from Drizzle schemas
 */
function generateDrizzleTypes(): void {
  console.log('üìù Generating types from Drizzle schemas...');
  
  try {
    // Run drizzle-kit introspect to get current DB state
    execSync('npx drizzle-kit introspect:pg', { stdio: 'inherit' });
    
    // Generate TypeScript types
    execSync('npx drizzle-kit generate:pg', { stdio: 'inherit' });
    
    console.log('‚úÖ Drizzle types generated successfully');
  } catch (error) {
    console.error('‚ùå Failed to generate Drizzle types:', error);
    process.exit(1);
  }
}

/**
 * Step 2: Extract and transform schema types
 */
function extractSchemaTypes(): void {
  console.log('üîç Extracting schema types...');
  
  const schemaFiles = fs.readdirSync(CONFIG.schemaDir)
    .filter(file => file.endsWith('-schema.ts'));
  
  const typeDefinitions: string[] = [];
  const zodSchemas: string[] = [];
  
  for (const file of schemaFiles) {
    const filePath = path.join(CONFIG.schemaDir, file);
    const content = fs.readFileSync(filePath, 'utf-8');
    
    // Extract table definitions
    const tableMatches = content.matchAll(/export const (\w+)Table = pgTable\(([\s\S]*?)\);/g);
    
    for (const match of tableMatches) {
      const tableName = match[1];
      const tableDefinition = match[2];
      
      // Generate TypeScript interface
      const interfaceName = tableName.charAt(0).toUpperCase() + tableName.slice(1);
      const typeDefinition = generateTypeFromTable(tableName, tableDefinition);
      typeDefinitions.push(typeDefinition);
      
      // Generate corresponding Zod schema
      const zodSchema = generateZodSchema(tableName, tableDefinition);
      zodSchemas.push(zodSchema);
    }
  }
  
  // Write generated types
  if (!fs.existsSync(CONFIG.typesDir)) {
    fs.mkdirSync(CONFIG.typesDir, { recursive: true });
  }
  
  const generatedTypesContent = `
/**
 * Auto-generated Types from Database Schemas
 * DO NOT EDIT - Generated by scripts/generate-types.ts
 * Last generated: ${new Date().toISOString()}
 */

${typeDefinitions.join('\n\n')}

// Re-export for convenience
export * from './index';
`.trim();
  
  fs.writeFileSync(path.join(CONFIG.typesDir, 'database.ts'), generatedTypesContent);
  
  // Write Zod schemas
  const validationContent = `
/**
 * Auto-generated Zod Schemas for Runtime Validation
 * DO NOT EDIT - Generated by scripts/generate-types.ts
 * Last generated: ${new Date().toISOString()}
 */

import { z } from 'zod';

${zodSchemas.join('\n\n')}
`.trim();
  
  fs.writeFileSync(CONFIG.validationFile, validationContent);
  
  console.log('‚úÖ Schema types extracted successfully');
}

/**
 * Generate TypeScript type from table definition
 */
function generateTypeFromTable(tableName: string, tableDefinition: string): string {
  const interfaceName = tableName.charAt(0).toUpperCase() + tableName.slice(1);
  
  // Parse column definitions
  const columnMatches = tableDefinition.matchAll(/(\w+):\s*(varchar|text|integer|boolean|timestamp|uuid|jsonb|decimal)\((.*?)\)/g);
  
  const properties: string[] = [];
  
  for (const match of columnMatches) {
    const [, columnName, columnType, options] = match;
    const tsType = mapDrizzleTypeToTS(columnType);
    const isOptional = options.includes('.notNull()') ? '' : '?';
    
    properties.push(`  readonly ${columnName}${isOptional}: ${tsType};`);
  }
  
  return `
export interface ${interfaceName} {
${properties.join('\n')}
  readonly createdAt: Date;
  readonly updatedAt: Date;
}

export interface New${interfaceName} {
${properties.filter(p => !p.includes('id') && !p.includes('createdAt') && !p.includes('updatedAt')).join('\n')}
}`;
}

/**
 * Generate Zod schema from table definition
 */
function generateZodSchema(tableName: string, tableDefinition: string): string {
  const schemaName = `${tableName}Schema`;
  
  // Parse column definitions
  const columnMatches = tableDefinition.matchAll(/(\w+):\s*(varchar|text|integer|boolean|timestamp|uuid|jsonb|decimal)\((.*?)\)/g);
  
  const zodProperties: string[] = [];
  
  for (const match of columnMatches) {
    const [, columnName, columnType, options] = match;
    const zodType = mapDrizzleTypeToZod(columnType, options);
    
    zodProperties.push(`  ${columnName}: ${zodType},`);
  }
  
  return `
export const ${schemaName} = z.object({
${zodProperties.join('\n')}
  createdAt: z.date(),
  updatedAt: z.date(),
});

export type ${tableName.charAt(0).toUpperCase() + tableName.slice(1)} = z.infer<typeof ${schemaName}>;`;
}

/**
 * Map Drizzle column types to TypeScript types
 */
function mapDrizzleTypeToTS(drizzleType: string): string {
  const typeMap: Record<string, string> = {
    varchar: 'string',
    text: 'string',
    integer: 'number',
    boolean: 'boolean',
    timestamp: 'Date',
    uuid: 'string',
    jsonb: 'Record<string, any>',
    decimal: 'number',
  };
  
  return typeMap[drizzleType] || 'unknown';
}

/**
 * Map Drizzle column types to Zod schemas
 */
function mapDrizzleTypeToZod(drizzleType: string, options: string): string {
  const baseTypeMap: Record<string, string> = {
    varchar: 'z.string()',
    text: 'z.string()',
    integer: 'z.number().int()',
    boolean: 'z.boolean()',
    timestamp: 'z.date()',
    uuid: 'z.string().uuid()',
    jsonb: 'z.record(z.any())',
    decimal: 'z.number()',
  };
  
  let zodType = baseTypeMap[drizzleType] || 'z.unknown()';
  
  // Add constraints based on options
  if (options.includes('.notNull()')) {
    // Already required by default in Zod
  } else {
    zodType += '.optional()';
  }
  
  if (options.includes('.default(')) {
    const defaultMatch = options.match(/\.default\((.*?)\)/);
    if (defaultMatch) {
      zodType += `.default(${defaultMatch[1]})`;
    }
  }
  
  return zodType;
}

/**
 * Step 3: Validate schema alignment
 */
async function validateSchemaAlignment(): Promise<void> {
  console.log('üîé Validating schema alignment...');
  
  const errors: string[] = [];
  
  // Check that all database types have corresponding Zod schemas
  const dbTypes = fs.readdirSync(CONFIG.typesDir)
    .filter(file => file.endsWith('.ts'))
    .map(file => file.replace('.ts', ''));
  
  const validationContent = fs.readFileSync(CONFIG.validationFile, 'utf-8');
  
  for (const typeName of dbTypes) {
    const schemaName = `${typeName}Schema`;
    if (!validationContent.includes(schemaName)) {
      errors.push(`Missing Zod schema for type: ${typeName}`);
    }
  }
  
  // Check for orphaned schemas
  const schemaMatches = validationContent.matchAll(/export const (\w+)Schema = z\.object/g);
  for (const match of schemaMatches) {
    const schemaName = match[1];
    const typeName = schemaName.replace('Schema', '');
    if (!dbTypes.includes(typeName.toLowerCase())) {
      errors.push(`Orphaned Zod schema: ${schemaName}`);
    }
  }
  
  if (errors.length > 0) {
    console.error('‚ùå Schema alignment issues found:');
    errors.forEach(error => console.error(`  - ${error}`));
    process.exit(1);
  }
  
  console.log('‚úÖ Schema alignment validated successfully');
}

/**
 * Step 4: Update index exports
 */
function updateIndexExports(): void {
  console.log('üì¶ Updating index exports...');
  
  const indexPath = path.join(CONFIG.typesDir, 'index.ts');
  const indexContent = `
/**
 * Generated Type Exports
 * Auto-generated by scripts/generate-types.ts
 */

// Database types
export * from './database';

// Validation schemas
export * from '../validation';

// Core types (manually maintained)
export * from '../core';
export * from '../api';
export * from '../stripe';
export * from '../schemas';
`.trim();
  
  fs.writeFileSync(indexPath, indexContent);
  
  console.log('‚úÖ Index exports updated');
}

/**
 * Main execution
 */
async function main(): Promise<void> {
  console.log('üöÄ Starting type generation pipeline...\n');
  
  try {
    generateDrizzleTypes();
    extractSchemaTypes();
    await validateSchemaAlignment();
    updateIndexExports();
    
    console.log('\n‚ú® Type generation completed successfully!');
    console.log('üìã Next steps:');
    console.log('  1. Review generated types in types/generated/');
    console.log('  2. Run npm run type-check to validate');
    console.log('  3. Commit generated files to version control');
  } catch (error) {
    console.error('\n‚ùå Type generation failed:', error);
    process.exit(1);
  }
}

// Run if called directly
if (require.main === module) {
  main().catch(console.error);
}

export { generateDrizzleTypes, validateSchemaAlignment };